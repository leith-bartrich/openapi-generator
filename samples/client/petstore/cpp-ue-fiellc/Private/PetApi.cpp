/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "PetApi.h"

#include "OpenAPIModule.h"

#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"
#include "PlatformHttp.h"

#include "ApiResponse.h"
#include "HttpFileInput.h"
#include "Pet.h"

////http helpers


HttpFileInput::HttpFileInput(const TCHAR* InFilePath)
{
	SetFilePath(InFilePath);
}

HttpFileInput::HttpFileInput(const FString& InFilePath)
{
	SetFilePath(InFilePath);
}

void HttpFileInput::SetFilePath(const TCHAR* InFilePath)
{
	FilePath = InFilePath;
	if(ContentType.IsEmpty())
	{
		ContentType = FPlatformHttp::GetMimeType(InFilePath);
	}
}

void HttpFileInput::SetFilePath(const FString& InFilePath)
{
	SetFilePath(*InFilePath);
}

void HttpFileInput::SetContentType(const TCHAR* InContentType)
{
	ContentType = InContentType;
}

FString HttpFileInput::GetFilename() const
{
	return FPaths::GetCleanFilename(FilePath);
}

const TCHAR* HttpMultipartFormData::Delimiter = TEXT("--");
const TCHAR* HttpMultipartFormData::Newline = TEXT("\r\n");

void HttpMultipartFormData::SetBoundary(const TCHAR* InBoundary)
{
	checkf(Boundary.IsEmpty(), TEXT("Boundary must be set before usage"));
	Boundary = InBoundary;
}

const FString& HttpMultipartFormData::GetBoundary() const
{
	if (Boundary.IsEmpty())
	{
		// Generate a random boundary with enough entropy, should avoid occurrences of the boundary in the data.
		// Since the boundary is generated at every request, in case of failure, retries should succeed.
		Boundary = FGuid::NewGuid().ToString(EGuidFormats::Short);
	}

	return Boundary;
}

void HttpMultipartFormData::SetupHttpRequest(const FHttpRequestRef& HttpRequest)
{
	if(HttpRequest->GetVerb() != TEXT("POST"))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Expected POST verb when using multipart form data"));
	}

	// Append final boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Delimiter);

	HttpRequest->SetHeader("Content-Type", FString::Printf(TEXT("multipart/form-data; boundary=%s"), *GetBoundary()));
	HttpRequest->SetContent(FormData);
}

void HttpMultipartFormData::AddStringPart(const TCHAR* Name, const TCHAR* Data)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name = \"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: text/plain; charset=utf-8")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	AppendString(Data);
	AppendString(Newline);
}

void HttpMultipartFormData::AddJsonPart(const TCHAR* Name, const FString& JsonString)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: application/json; charset=utf-8")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	AppendString(*JsonString);
	AppendString(Newline);
}

void HttpMultipartFormData::AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: application/octet-stream")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	FormData.Append(ByteArray);
	AppendString(Newline);
}

void HttpMultipartFormData::AddFilePart(const TCHAR* Name, const HttpFileInput& File)
{
	TArray<uint8> FileContents;
	if (!FFileHelper::LoadFileToArray(FileContents, *File.GetFilePath()))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Failed to load file (%s)"), *File.GetFilePath());
		return;
	}

	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\"; filename=\"%s\""), Name, *File.GetFilename()));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: %s"), *File.GetContentType()));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	FormData.Append(FileContents);
	AppendString(Newline);
}

void HttpMultipartFormData::AppendString(const TCHAR* Str)
{
	FTCHARToUTF8 utf8Str(Str);
	FormData.Append((uint8*)utf8Str.Get(), utf8Str.Length());
}

////API


void UOAPIPetApi::SetURL(const FString& InUrl)
{
    this->Url = InUrl;
}

void UOAPIPetApi::AddHeaderParam(const FString& Key, const FString& Value)
{
    this->AdditionalHeaderParams.Add(Key, Value);
}

void UOAPIPetApi::ClearHeaderParams( )
{
    this->AdditionalHeaderParams.Reset();
}
UOAPIActiveRequestHandle* UOAPIPetApi::DoAddPetRequestStatic(UOAPIAddPetRequest* In_Request, TFunction<void(UOAPIAddPetResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIAddPetResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 405:
        restResponse->RestResponseDescription = TEXT("Invalid input");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoAddPetRequest(UOAPIAddPetRequest* In_Request, const FOnOAPIAddPetResponseDelegate& on_response)
{
    return this->DoAddPetRequestStatic(In_Request, [on_response](UOAPIAddPetResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIAddPetRequest::ComputePath() const
{
	FString Path(TEXT("/pet"));
	return Path;
}

void UOAPIAddPetRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;
    Consumes.Add("application/json");
    Consumes.Add("application/xml");

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIAddPetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIPetApi::DoDeletePetRequestStatic(UOAPIDeletePetRequest* In_Request, TFunction<void(UOAPIDeletePetResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIDeletePetResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid pet value");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoDeletePetRequest(UOAPIDeletePetRequest* In_Request, const FOnOAPIDeletePetResponseDelegate& on_response)
{
    return this->DoDeletePetRequestStatic(In_Request, [on_response](UOAPIDeletePetResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIDeletePetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("petId"), openapi::ToStringFormatArg(PetId));

	FString Path = FString::Format(TEXT("/pet/{petId}"), PathParams);

	return Path;
}

void UOAPIDeletePetRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (ApiKey.IsSet())
	{
    In_HttpRequest->SetHeader(TEXT("api_key"), ApiKey.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIDeletePetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIPetApi::DoFindPetsByStatusRequestStatic(UOAPIFindPetsByStatusRequest* In_Request, TFunction<void(UOAPIFindPetsByStatusResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIFindPetsByStatusResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid status value");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoFindPetsByStatusRequest(UOAPIFindPetsByStatusRequest* In_Request, const FOnOAPIFindPetsByStatusResponseDelegate& on_response)
{
    return this->DoFindPetsByStatusRequestStatic(In_Request, [on_response](UOAPIFindPetsByStatusResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIFindPetsByStatusRequest::ComputePath() const
{
	FString Path(TEXT("/pet/findByStatus"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("status=")) + CollectionToUrlString_csv(Status, TEXT("status")));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void UOAPIFindPetsByStatusRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIFindPetsByStatusResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{

            
    return openapi::TryGetJsonValue(JsonValue, Content);
            }



UOAPIActiveRequestHandle* UOAPIPetApi::DoFindPetsByTagsRequestStatic(UOAPIFindPetsByTagsRequest* In_Request, TFunction<void(UOAPIFindPetsByTagsResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIFindPetsByTagsResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid tag value");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoFindPetsByTagsRequest(UOAPIFindPetsByTagsRequest* In_Request, const FOnOAPIFindPetsByTagsResponseDelegate& on_response)
{
    return this->DoFindPetsByTagsRequestStatic(In_Request, [on_response](UOAPIFindPetsByTagsResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIFindPetsByTagsRequest::ComputePath() const
{
	FString Path(TEXT("/pet/findByTags"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("tags=")) + CollectionToUrlString_csv(Tags, TEXT("tags")));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void UOAPIFindPetsByTagsRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIFindPetsByTagsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{

            
    return openapi::TryGetJsonValue(JsonValue, Content);
            }



UOAPIActiveRequestHandle* UOAPIPetApi::DoGetPetByIdRequestStatic(UOAPIGetPetByIdRequest* In_Request, TFunction<void(UOAPIGetPetByIdResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIGetPetByIdResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid ID supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("Pet not found");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoGetPetByIdRequest(UOAPIGetPetByIdRequest* In_Request, const FOnOAPIGetPetByIdResponseDelegate& on_response)
{
    return this->DoGetPetByIdRequestStatic(In_Request, [on_response](UOAPIGetPetByIdResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIGetPetByIdRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("petId"), openapi::ToStringFormatArg(PetId));

	FString Path = FString::Format(TEXT("/pet/{petId}"), PathParams);

	return Path;
}

void UOAPIGetPetByIdRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIGetPetByIdResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return openapi::TryGetJsonValue(JsonValue, Content);
        }



UOAPIActiveRequestHandle* UOAPIPetApi::DoUpdatePetRequestStatic(UOAPIUpdatePetRequest* In_Request, TFunction<void(UOAPIUpdatePetResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIUpdatePetResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid ID supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("Pet not found");
        break;
        case 405:
        restResponse->RestResponseDescription = TEXT("Validation exception");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoUpdatePetRequest(UOAPIUpdatePetRequest* In_Request, const FOnOAPIUpdatePetResponseDelegate& on_response)
{
    return this->DoUpdatePetRequestStatic(In_Request, [on_response](UOAPIUpdatePetResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIUpdatePetRequest::ComputePath() const
{
	FString Path(TEXT("/pet"));
	return Path;
}

void UOAPIUpdatePetRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;
    Consumes.Add("application/json");
    Consumes.Add("application/xml");

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("PUT"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIUpdatePetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIPetApi::DoUpdatePetWithFormRequestStatic(UOAPIUpdatePetWithFormRequest* In_Request, TFunction<void(UOAPIUpdatePetWithFormResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIUpdatePetWithFormResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 405:
        restResponse->RestResponseDescription = TEXT("Invalid input");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoUpdatePetWithFormRequest(UOAPIUpdatePetWithFormRequest* In_Request, const FOnOAPIUpdatePetWithFormResponseDelegate& on_response)
{
    return this->DoUpdatePetWithFormRequestStatic(In_Request, [on_response](UOAPIUpdatePetWithFormResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIUpdatePetWithFormRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("petId"), openapi::ToStringFormatArg(PetId));

	FString Path = FString::Format(TEXT("/pet/{petId}"), PathParams);

	return Path;
}

void UOAPIUpdatePetWithFormRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;
    Consumes.Add("application/x-www-form-urlencoded");

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		if (Name.IsSet()){
			Writer->WriteIdentifierPrefix(TEXT("name"));
            openapi::WriteJsonValue(Writer, Name.GetValue());
		}
		if (Status.IsSet()){
			Writer->WriteIdentifierPrefix(TEXT("status"));
            openapi::WriteJsonValue(Writer, Status.GetValue());
		}
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		HttpMultipartFormData FormData;
		if(Name.IsSet())
		{
			FormData.AddStringPart(TEXT("name"), *openapi::ToUrlString(Name.GetValue()));
		}
		if(Status.IsSet())
		{
			FormData.AddStringPart(TEXT("status"), *openapi::ToUrlString(Status.GetValue()));
		}

		FormData.SetupHttpRequest(In_HttpRequest);
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		TArray<FString> FormParams;
		if(Name.IsSet())
		{
			FormParams.Add(FString(TEXT("name=")) + openapi::ToUrlString(Name.GetValue()));
		}
		if(Status.IsSet())
		{
			FormParams.Add(FString(TEXT("status=")) + openapi::ToUrlString(Status.GetValue()));
		}

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/x-www-form-urlencoded; charset=utf-8"));
        In_HttpRequest->SetContentAsString(FString::Join(FormParams, TEXT("&")));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIUpdatePetWithFormResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIPetApi::DoUploadFileRequestStatic(UOAPIUploadFileRequest* In_Request, TFunction<void(UOAPIUploadFileResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIUploadFileResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIPetApi::DoUploadFileRequest(UOAPIUploadFileRequest* In_Request, const FOnOAPIUploadFileResponseDelegate& on_response)
{
    return this->DoUploadFileRequestStatic(In_Request, [on_response](UOAPIUploadFileResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIUploadFileRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("petId"), openapi::ToStringFormatArg(PetId));

	FString Path = FString::Format(TEXT("/pet/{petId}/uploadImage"), PathParams);

	return Path;
}

void UOAPIUploadFileRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;
    Consumes.Add("multipart/form-data");

	//static const TArray<FString> Produces = { TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		if (AdditionalMetadata.IsSet()){
			Writer->WriteIdentifierPrefix(TEXT("additionalMetadata"));
            openapi::WriteJsonValue(Writer, AdditionalMetadata.GetValue());
		}
		if (File.IsSet()){
			Writer->WriteIdentifierPrefix(TEXT("file"));
            openapi::WriteJsonValue(Writer, File.GetValue());
		}
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		HttpMultipartFormData FormData;
		if(AdditionalMetadata.IsSet())
		{
			FormData.AddStringPart(TEXT("additionalMetadata"), *openapi::ToUrlString(AdditionalMetadata.GetValue()));
		}
		if(File.IsSet())
		{
			FormData.AddFilePart(TEXT("file"), File.GetValue());
		}

		FormData.SetupHttpRequest(In_HttpRequest);
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		TArray<FString> FormParams;
		if(AdditionalMetadata.IsSet())
		{
			FormParams.Add(FString(TEXT("additionalMetadata=")) + openapi::ToUrlString(AdditionalMetadata.GetValue()));
		}
		UE_LOG(LogOpenAPI, Error, TEXT("Form parameter (file) was ignored, Files are not supported in urlencoded requests"));

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/x-www-form-urlencoded; charset=utf-8"));
        In_HttpRequest->SetContentAsString(FString::Join(FormParams, TEXT("&")));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIUploadFileResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return openapi::TryGetJsonValue(JsonValue, Content);
        }




namespace openapi
{


}

/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "UserApi.h"

#include "OpenAPIModule.h"

#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"
#include "PlatformHttp.h"

#include "User.h"

////http helpers


HttpFileInput::HttpFileInput(const TCHAR* InFilePath)
{
	SetFilePath(InFilePath);
}

HttpFileInput::HttpFileInput(const FString& InFilePath)
{
	SetFilePath(InFilePath);
}

void HttpFileInput::SetFilePath(const TCHAR* InFilePath)
{
	FilePath = InFilePath;
	if(ContentType.IsEmpty())
	{
		ContentType = FPlatformHttp::GetMimeType(InFilePath);
	}
}

void HttpFileInput::SetFilePath(const FString& InFilePath)
{
	SetFilePath(*InFilePath);
}

void HttpFileInput::SetContentType(const TCHAR* InContentType)
{
	ContentType = InContentType;
}

FString HttpFileInput::GetFilename() const
{
	return FPaths::GetCleanFilename(FilePath);
}

const TCHAR* HttpMultipartFormData::Delimiter = TEXT("--");
const TCHAR* HttpMultipartFormData::Newline = TEXT("\r\n");

void HttpMultipartFormData::SetBoundary(const TCHAR* InBoundary)
{
	checkf(Boundary.IsEmpty(), TEXT("Boundary must be set before usage"));
	Boundary = InBoundary;
}

const FString& HttpMultipartFormData::GetBoundary() const
{
	if (Boundary.IsEmpty())
	{
		// Generate a random boundary with enough entropy, should avoid occurrences of the boundary in the data.
		// Since the boundary is generated at every request, in case of failure, retries should succeed.
		Boundary = FGuid::NewGuid().ToString(EGuidFormats::Short);
	}

	return Boundary;
}

void HttpMultipartFormData::SetupHttpRequest(const FHttpRequestRef& HttpRequest)
{
	if(HttpRequest->GetVerb() != TEXT("POST"))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Expected POST verb when using multipart form data"));
	}

	// Append final boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Delimiter);

	HttpRequest->SetHeader("Content-Type", FString::Printf(TEXT("multipart/form-data; boundary=%s"), *GetBoundary()));
	HttpRequest->SetContent(FormData);
}

void HttpMultipartFormData::AddStringPart(const TCHAR* Name, const TCHAR* Data)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name = \"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: text/plain; charset=utf-8")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	AppendString(Data);
	AppendString(Newline);
}

void HttpMultipartFormData::AddJsonPart(const TCHAR* Name, const FString& JsonString)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: application/json; charset=utf-8")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	AppendString(*JsonString);
	AppendString(Newline);
}

void HttpMultipartFormData::AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: application/octet-stream")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	FormData.Append(ByteArray);
	AppendString(Newline);
}

void HttpMultipartFormData::AddFilePart(const TCHAR* Name, const HttpFileInput& File)
{
	TArray<uint8> FileContents;
	if (!FFileHelper::LoadFileToArray(FileContents, *File.GetFilePath()))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Failed to load file (%s)"), *File.GetFilePath());
		return;
	}

	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\"; filename=\"%s\""), Name, *File.GetFilename()));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: %s"), *File.GetContentType()));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	FormData.Append(FileContents);
	AppendString(Newline);
}

void HttpMultipartFormData::AppendString(const TCHAR* Str)
{
	FTCHARToUTF8 utf8Str(Str);
	FormData.Append((uint8*)utf8Str.Get(), utf8Str.Length());
}

////API


void UOAPIUserApi::SetURL(const FString& InUrl)
{
    this->Url = InUrl;
}

void UOAPIUserApi::AddHeaderParam(const FString& Key, const FString& Value)
{
    this->AdditionalHeaderParams.Add(Key, Value);
}

void UOAPIUserApi::ClearHeaderParams( )
{
    this->AdditionalHeaderParams.Reset();
}
UOAPIActiveRequestHandle* UOAPIUserApi::DoCreateUserRequestStatic(UOAPICreateUserRequest* In_Request, TFunction<void(UOAPICreateUserResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPICreateUserResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 0:
            default:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoCreateUserRequest(UOAPICreateUserRequest* In_Request, const FOnOAPICreateUserResponseDelegate& on_response)
{
    return this->DoCreateUserRequestStatic(In_Request, [on_response](UOAPICreateUserResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPICreateUserRequest::ComputePath() const
{
	FString Path(TEXT("/user"));
	return Path;
}

void UOAPICreateUserRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPICreateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIUserApi::DoCreateUsersWithArrayInputRequestStatic(UOAPICreateUsersWithArrayInputRequest* In_Request, TFunction<void(UOAPICreateUsersWithArrayInputResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPICreateUsersWithArrayInputResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 0:
            default:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoCreateUsersWithArrayInputRequest(UOAPICreateUsersWithArrayInputRequest* In_Request, const FOnOAPICreateUsersWithArrayInputResponseDelegate& on_response)
{
    return this->DoCreateUsersWithArrayInputRequestStatic(In_Request, [on_response](UOAPICreateUsersWithArrayInputResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPICreateUsersWithArrayInputRequest::ComputePath() const
{
	FString Path(TEXT("/user/createWithArray"));
	return Path;
}

void UOAPICreateUsersWithArrayInputRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPICreateUsersWithArrayInputResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIUserApi::DoCreateUsersWithListInputRequestStatic(UOAPICreateUsersWithListInputRequest* In_Request, TFunction<void(UOAPICreateUsersWithListInputResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPICreateUsersWithListInputResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 0:
            default:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoCreateUsersWithListInputRequest(UOAPICreateUsersWithListInputRequest* In_Request, const FOnOAPICreateUsersWithListInputResponseDelegate& on_response)
{
    return this->DoCreateUsersWithListInputRequestStatic(In_Request, [on_response](UOAPICreateUsersWithListInputResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPICreateUsersWithListInputRequest::ComputePath() const
{
	FString Path(TEXT("/user/createWithList"));
	return Path;
}

void UOAPICreateUsersWithListInputRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPICreateUsersWithListInputResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIUserApi::DoDeleteUserRequestStatic(UOAPIDeleteUserRequest* In_Request, TFunction<void(UOAPIDeleteUserResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIDeleteUserResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid username supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("User not found");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoDeleteUserRequest(UOAPIDeleteUserRequest* In_Request, const FOnOAPIDeleteUserResponseDelegate& on_response)
{
    return this->DoDeleteUserRequestStatic(In_Request, [on_response](UOAPIDeleteUserResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIDeleteUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("username"), openapi::ToStringFormatArg(Username));

	FString Path = FString::Format(TEXT("/user/{username}"), PathParams);

	return Path;
}

void UOAPIDeleteUserRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIDeleteUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIUserApi::DoGetUserByNameRequestStatic(UOAPIGetUserByNameRequest* In_Request, TFunction<void(UOAPIGetUserByNameResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIGetUserByNameResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid username supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("User not found");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoGetUserByNameRequest(UOAPIGetUserByNameRequest* In_Request, const FOnOAPIGetUserByNameResponseDelegate& on_response)
{
    return this->DoGetUserByNameRequestStatic(In_Request, [on_response](UOAPIGetUserByNameResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIGetUserByNameRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("username"), openapi::ToStringFormatArg(Username));

	FString Path = FString::Format(TEXT("/user/{username}"), PathParams);

	return Path;
}

void UOAPIGetUserByNameRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIGetUserByNameResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return openapi::TryGetJsonValue(JsonValue, Content);
        }



UOAPIActiveRequestHandle* UOAPIUserApi::DoLoginUserRequestStatic(UOAPILoginUserRequest* In_Request, TFunction<void(UOAPILoginUserResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPILoginUserResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid username/password supplied");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoLoginUserRequest(UOAPILoginUserRequest* In_Request, const FOnOAPILoginUserResponseDelegate& on_response)
{
    return this->DoLoginUserRequestStatic(In_Request, [on_response](UOAPILoginUserResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPILoginUserRequest::ComputePath() const
{
	FString Path(TEXT("/user/login"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("username=")) + ToUrlString(Username));
	QueryParams.Add(FString(TEXT("password=")) + ToUrlString(Password));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void UOAPILoginUserRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPILoginUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{

            
    return openapi::TryGetJsonValue(JsonValue, Content);
}



UOAPIActiveRequestHandle* UOAPIUserApi::DoLogoutUserRequestStatic(UOAPILogoutUserRequest* In_Request, TFunction<void(UOAPILogoutUserResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPILogoutUserResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 0:
            default:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoLogoutUserRequest(UOAPILogoutUserRequest* In_Request, const FOnOAPILogoutUserResponseDelegate& on_response)
{
    return this->DoLogoutUserRequestStatic(In_Request, [on_response](UOAPILogoutUserResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPILogoutUserRequest::ComputePath() const
{
	FString Path(TEXT("/user/logout"));
	return Path;
}

void UOAPILogoutUserRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPILogoutUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIUserApi::DoUpdateUserRequestStatic(UOAPIUpdateUserRequest* In_Request, TFunction<void(UOAPIUpdateUserResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIUpdateUserResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid user supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("User not found");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIUserApi::DoUpdateUserRequest(UOAPIUpdateUserRequest* In_Request, const FOnOAPIUpdateUserResponseDelegate& on_response)
{
    return this->DoUpdateUserRequestStatic(In_Request, [on_response](UOAPIUpdateUserResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIUpdateUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("username"), openapi::ToStringFormatArg(Username));

	FString Path = FString::Format(TEXT("/user/{username}"), PathParams);

	return Path;
}

void UOAPIUpdateUserRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("PUT"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIUpdateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}




namespace openapi
{


}

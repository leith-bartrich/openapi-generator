/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "StoreApi.h"

#include "OpenAPIModule.h"

#include "HttpModule.h"
#include "Serialization/JsonSerializer.h"
#include "PlatformHttp.h"

#include "Order.h"

////http helpers


HttpFileInput::HttpFileInput(const TCHAR* InFilePath)
{
	SetFilePath(InFilePath);
}

HttpFileInput::HttpFileInput(const FString& InFilePath)
{
	SetFilePath(InFilePath);
}

void HttpFileInput::SetFilePath(const TCHAR* InFilePath)
{
	FilePath = InFilePath;
	if(ContentType.IsEmpty())
	{
		ContentType = FPlatformHttp::GetMimeType(InFilePath);
	}
}

void HttpFileInput::SetFilePath(const FString& InFilePath)
{
	SetFilePath(*InFilePath);
}

void HttpFileInput::SetContentType(const TCHAR* InContentType)
{
	ContentType = InContentType;
}

FString HttpFileInput::GetFilename() const
{
	return FPaths::GetCleanFilename(FilePath);
}

const TCHAR* HttpMultipartFormData::Delimiter = TEXT("--");
const TCHAR* HttpMultipartFormData::Newline = TEXT("\r\n");

void HttpMultipartFormData::SetBoundary(const TCHAR* InBoundary)
{
	checkf(Boundary.IsEmpty(), TEXT("Boundary must be set before usage"));
	Boundary = InBoundary;
}

const FString& HttpMultipartFormData::GetBoundary() const
{
	if (Boundary.IsEmpty())
	{
		// Generate a random boundary with enough entropy, should avoid occurrences of the boundary in the data.
		// Since the boundary is generated at every request, in case of failure, retries should succeed.
		Boundary = FGuid::NewGuid().ToString(EGuidFormats::Short);
	}

	return Boundary;
}

void HttpMultipartFormData::SetupHttpRequest(const FHttpRequestRef& HttpRequest)
{
	if(HttpRequest->GetVerb() != TEXT("POST"))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Expected POST verb when using multipart form data"));
	}

	// Append final boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Delimiter);

	HttpRequest->SetHeader("Content-Type", FString::Printf(TEXT("multipart/form-data; boundary=%s"), *GetBoundary()));
	HttpRequest->SetContent(FormData);
}

void HttpMultipartFormData::AddStringPart(const TCHAR* Name, const TCHAR* Data)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name = \"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: text/plain; charset=utf-8")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	AppendString(Data);
	AppendString(Newline);
}

void HttpMultipartFormData::AddJsonPart(const TCHAR* Name, const FString& JsonString)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: application/json; charset=utf-8")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	AppendString(*JsonString);
	AppendString(Newline);
}

void HttpMultipartFormData::AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray)
{
	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\""), Name));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: application/octet-stream")));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	FormData.Append(ByteArray);
	AppendString(Newline);
}

void HttpMultipartFormData::AddFilePart(const TCHAR* Name, const HttpFileInput& File)
{
	TArray<uint8> FileContents;
	if (!FFileHelper::LoadFileToArray(FileContents, *File.GetFilePath()))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Failed to load file (%s)"), *File.GetFilePath());
		return;
	}

	// Add boundary
	AppendString(Delimiter);
	AppendString(*GetBoundary());
	AppendString(Newline);

	// Add header
	AppendString(*FString::Printf(TEXT("Content-Disposition: form-data; name=\"%s\"; filename=\"%s\""), Name, *File.GetFilename()));
	AppendString(Newline);
	AppendString(*FString::Printf(TEXT("Content-Type: %s"), *File.GetContentType()));
	AppendString(Newline);

	// Add header to body splitter
	AppendString(Newline);

	// Add Data
	FormData.Append(FileContents);
	AppendString(Newline);
}

void HttpMultipartFormData::AppendString(const TCHAR* Str)
{
	FTCHARToUTF8 utf8Str(Str);
	FormData.Append((uint8*)utf8Str.Get(), utf8Str.Length());
}

////API


void UOAPIStoreApi::SetURL(const FString& InUrl)
{
    this->Url = InUrl;
}

void UOAPIStoreApi::AddHeaderParam(const FString& Key, const FString& Value)
{
    this->AdditionalHeaderParams.Add(Key, Value);
}

void UOAPIStoreApi::ClearHeaderParams( )
{
    this->AdditionalHeaderParams.Reset();
}
UOAPIActiveRequestHandle* UOAPIStoreApi::DoDeleteOrderRequestStatic(UOAPIDeleteOrderRequest* In_Request, TFunction<void(UOAPIDeleteOrderResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIDeleteOrderResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid ID supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("Order not found");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIStoreApi::DoDeleteOrderRequest(UOAPIDeleteOrderRequest* In_Request, const FOnOAPIDeleteOrderResponseDelegate& on_response)
{
    return this->DoDeleteOrderRequestStatic(In_Request, [on_response](UOAPIDeleteOrderResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIDeleteOrderRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("orderId"), openapi::ToStringFormatArg(OrderId));

	FString Path = FString::Format(TEXT("/store/order/{orderId}"), PathParams);

	return Path;
}

void UOAPIDeleteOrderRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = {  };

    In_HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIDeleteOrderResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return true;
}



UOAPIActiveRequestHandle* UOAPIStoreApi::DoGetInventoryRequestStatic(UOAPIGetInventoryRequest* In_Request, TFunction<void(UOAPIGetInventoryResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIGetInventoryResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIStoreApi::DoGetInventoryRequest(UOAPIGetInventoryRequest* In_Request, const FOnOAPIGetInventoryResponseDelegate& on_response)
{
    return this->DoGetInventoryRequestStatic(In_Request, [on_response](UOAPIGetInventoryResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIGetInventoryRequest::ComputePath() const
{
	FString Path(TEXT("/store/inventory"));
	return Path;
}

void UOAPIGetInventoryRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIGetInventoryResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{

            
    return openapi::TryGetJsonValue(JsonValue, Content);
}



UOAPIActiveRequestHandle* UOAPIStoreApi::DoGetOrderByIdRequestStatic(UOAPIGetOrderByIdRequest* In_Request, TFunction<void(UOAPIGetOrderByIdResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIGetOrderByIdResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid ID supplied");
        break;
        case 404:
        restResponse->RestResponseDescription = TEXT("Order not found");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIStoreApi::DoGetOrderByIdRequest(UOAPIGetOrderByIdRequest* In_Request, const FOnOAPIGetOrderByIdResponseDelegate& on_response)
{
    return this->DoGetOrderByIdRequestStatic(In_Request, [on_response](UOAPIGetOrderByIdResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIGetOrderByIdRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams;
    PathParams.Add(TEXT("orderId"), openapi::ToStringFormatArg(OrderId));

	FString Path = FString::Format(TEXT("/store/order/{orderId}"), PathParams);

	return Path;
}

void UOAPIGetOrderByIdRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Form parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
		Writer->Close();
        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIGetOrderByIdResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return openapi::TryGetJsonValue(JsonValue, Content);
        }



UOAPIActiveRequestHandle* UOAPIStoreApi::DoPlaceOrderRequestStatic(UOAPIPlaceOrderRequest* In_Request, TFunction<void(UOAPIPlaceOrderResponse*)> on_response){
    auto cancel_handle = NewObject<UOAPIActiveRequestHandle>();
    auto httpRequest = FHttpModule::Get().CreateRequest();
    httpRequest->SetURL(*(Url + In_Request->ComputePath()));

    for(const auto& It : this->AdditionalHeaderParams)
    {
    httpRequest->SetHeader(It.Key, It.Value);
    }

    In_Request->SetupHttpRequest(httpRequest);
    In_Request->HttpRequest = httpRequest;
    httpRequest->OnProcessRequestComplete().BindLambda([this,In_Request,on_response](FHttpRequestPtr request, FHttpResponsePtr response, bool connectedSuccessfully)
    {
    this->Processing_Requests.Remove(In_Request);
    auto restResponse = NewObject<UOAPIPlaceOrderResponse>();
    restResponse->Request = In_Request;

    auto requestStatus = request->GetStatus();
    if (requestStatus == EHttpRequestStatus::Failed){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = false;
    on_response(restResponse);
    return;
    }

    if (requestStatus == EHttpRequestStatus::Failed_ConnectionError){
    restResponse->HttpRequestFailed = true;
    restResponse->HttpConnectionFailed = true;
    on_response(restResponse);
    return;
    }

    restResponse->HttpResponseCode = response->GetResponseCode();
    restResponse->RestSuccess = EHttpResponseCodes::IsOk(restResponse->HttpResponseCode);

    switch ((int32)restResponse->HttpResponseCode)
    {
        case 200:
        restResponse->RestResponseDescription = TEXT("successful operation");
        break;
        case 400:
        restResponse->RestResponseDescription = TEXT("Invalid Order");
        break;
    }

    restResponse->HttpContentType = response->GetContentType();

    if (restResponse->HttpContentType.GetValue().IsEmpty()){
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("application/json")) || restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/json"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    TSharedPtr<FJsonValue> JsonValue;
    auto Reader = TJsonReaderFactory<>::Create(restResponse->RestResponseContentString.GetValue());
    bool deserialized = FJsonSerializer::Deserialize(Reader, JsonValue);
    bool validJSON = JsonValue.IsValid();
    if (!(deserialized & validJSON)){
    on_response(restResponse);
    return;
    }
    bool parseSuccessful = restResponse->FromJson(JsonValue);
    restResponse->RestParseSuccessful = parseSuccessful;
    on_response(restResponse);
    return;
    } else if (restResponse->HttpContentType.GetValue().StartsWith(TEXT("text/plain"))) {
    restResponse->RestResponseContentString = response->GetContentAsString();
    on_response(restResponse);
    return;
    }
    });
    httpRequest->ProcessRequest();
    this->Processing_Requests.Add(In_Request);
    cancel_handle->HttpRequest = httpRequest;
    cancel_handle->Request = In_Request;
    return cancel_handle;

}


UOAPIActiveRequestHandle* UOAPIStoreApi::DoPlaceOrderRequest(UOAPIPlaceOrderRequest* In_Request, const FOnOAPIPlaceOrderResponseDelegate& on_response)
{
    return this->DoPlaceOrderRequestStatic(In_Request, [on_response](UOAPIPlaceOrderResponse * response){on_response.ExecuteIfBound(response);});
}

FString UOAPIPlaceOrderRequest::ComputePath() const
{
	FString Path(TEXT("/store/order"));
	return Path;
}

void UOAPIPlaceOrderRequest::SetupHttpRequest(const FHttpRequestRef& In_HttpRequest) const
{
	TArray<FString> Consumes;

	//static const TArray<FString> Produces = { TEXT("application/xml"), TEXT("application/json") };

    In_HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

            openapi::WriteJsonValue(Writer, Body);
		Writer->Close();

        In_HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
        In_HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (body) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}


bool  UOAPIPlaceOrderResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
    return openapi::TryGetJsonValue(JsonValue, Content);
        }




namespace openapi
{


}
